----------------------2022.2.7------------------------

x x --> y x
y y       y x 

y y --> y x
x x      y x

x y --> x x --> y x
y x       y y      y x

/* 先分别统计这两对字符串中这两种格式的对儿 <x, y> 和 <y, x> 有多少 */
/* 然后如果 <x, y> 的数量和 <y, x> 的数量之和是奇数，则直接返回 -1 */
/* 否则如果每个都是偶数，则返回和的一半。如果每个都是奇数，则返回和的一半 + 1 */

/* 构造测试样例：
* s1 = "xxx", s2 = "yyy", answer = -1.
* s1 = "xyyx", s2 = "yxxy", answer = 2. 
*/

#include <string>

class Solution {
public:
	int minimumSwap(string s1, string s2) {
		int cnt1 = 0, cnt2 = 0;
		int len = s1.size(); /* len = 4 */
		for (int i = 0; i < len; i++) {
			if (s1[i] == 'x' && s2[i] == 'y') cnt1++;
			else if (s1[i] == 'y' && s2[i] == 'x') cnt2++;
			else {};
		}; /* cnt1 = 2, cnt2 = 2 */
		int ans = (cnt1 + cnt2) & 1 ? -1 : ((cnt1 + cnt2) >> 1) + (cnt1 & 1);
		return ans; /* ans = 2 */
	};
};





/* 先统计出所有的奇数数字的位置，然后以 k 为大小的滑动窗口去遍历
* 这样就能算出恰好含有 k 个奇数数字的 “极小” 子数组，然后再去看两侧奇数的位置，相乘就可以算出含有部分 “多余偶数” 的数组有多少个
*/

/* 测试用例, nums = <1 1 2 1 1>, k = 2, ans = 5 */
/* 时间复杂度: O(N), 空间复杂度: O(N) */

#include <vector>

using namespace std;

class Solution{
public:
	int numberOfSubarrays(vector<int>& nums, int k ){
	  /* nums: 1 1 2 1 1 */
		int len = nums.size();
		vector<int> v; v.push_back(-1);
		for (int i = 0; i < len; i++)
			if (nums[i] & 1) {
				v.push_back(i);
			};
		v.push_back(len);
		/* v: -1 0 1 3 4 5 */
		int ans = 0;
		for (int start = 1; start < v.size(); start++) {
			int end = start + k - 1;
			if (end >= v.size() - 1) break;
			else ans += (v[start] - v[start - 1]) * (v[end + 1] - v[end]); /* ans += 2 += 1 += 2 = 5 */
		};
		return ans;
	};
};








/* 我们使用栈把字符串中的括号依次压栈，每次压栈的规则是
* 如果栈为空，则直接压栈。如果栈顶元素是左括号，且当前元素是右括号，刚好匹配，则探出栈顶元素且不压栈当前元素。否则，将当前元素压栈。最后的栈内所有元素就是要被移除的括号。
* 每次压栈时需要记录位置信息，以便后续删除对应字符串中的括号来获得新的合法字符串。
* 因此，可以压栈一个数字，如果是左括号则用负号，右括号则用正号，下标从 1 开始。
*/

/* 测试用例: s = "(d)(f))", ans = 1 */
/* 时间复杂度: O(N), 空间复杂度: O(N) */

#include<stack>

class Solution{
public:
	string minRemoveToMakeValid(string s){
		stack<int> ele;
		for (int i = 0; i < s.size(); i++) 
			if (s[i] == '(') ele.push(-(i + 1));
			else if (s[i] == ')') {
				if (ele.empty()) ele.push(i + 1);
				else if (ele.top() < 0) ele.pop();
				else ele.push(i + 1);
			} else {};
		string ans = "";
		int cur_idx = s.size();
		
		while (!ele.empty()) {
			int last_idx = abs(ele.top()) - 1;
			ele.pop();
			ans = s.substr(last_idx + 1, cur_idx - last_idx - 1) + ans;
			cur_idx = last_idx;
		};
		ans = s.substr(0, cur_idx - 0) + ans;
		/*for (int i = s.size() - 1; i >= 0; i--) {
			if (!ele.empty() && abs(ele.top()) - 1 == i) {
				ele.pop();
			} else {
				ans = s[i] + ans;
			};
		};*/
		return ans;
	};
};



/* 查看了维基百科 <裴蜀定理> */
/* 当且仅当 m 是 a, b 的最大公约数的倍数，ax + by = m 才有解, 此题中 m = 1，因此就是判断 a 和 b 互质 */

class Solution{
public:
	int gcd(int a, int b) {
		return a == 0 ? b : gcd(b % a, a);
	};
	bool isGoodArray(vector<int>& nums) {
		int a = nums[0];
		for (auto num: nums)
			a = gcd(a, num);
		return a == 1;
	};
};


-----------------------2022.2.8-----------------------------


/* 遍历原来数组，每次将奇数位上的数量的偶数位上的值压入结果数组，返回即可 */
/* 测试用例：v = {1 3 2 4 5 2}, ans = {3 4 4 2 2 2 2 2} */
/* 时间复杂度：O(N * max(nums)) 空间复杂度：O(N * max(nums)) */

#include <vector>

using namespace std;

class Solution{
public:
  vector<int> decompressRLElist(vector<int>& nums){
    vector<int> ans;
    int len = nums.size();
    for (int i = 0; i < len; i += 2) {
      for (int j = 0; j < nums[i]; j++) {
          ans.push_back(nums[i + 1]);
      };
    };
    return ans;
  };
};


/* 前缀和思想：按行求出前缀和，计算每个元素的时候都根据前缀和按行求出的总和即可 */
/* 测试用例：mat = { 1 2 3      k = 1, ans = { 12, 21, 16
                   4 5 6                     27, 45, 33 
                   7 8 9 }                   24, 39, 28}
*/
/* 时间复杂度：O(m * n) 空间复杂度：O(m * n) */

#include <vector>

using namespace std;

class Solution{
public:
  vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {
    int m = mat.size(), n = mat[0].size(); /* m = 3, n = 3 */
    vector<vector<int>> prefix(m, vector<int>(n, 0));
    /* prefix = { 1 3 6 
                  5 12 21
                  12 27 45 }
    */
    for (int i = 0; i < m; i++) {
      for (int j = 0; j < n; j++) {
        if (i == 0 && j == 0) prefix[i][j] = mat[i][j]; 
        else if (i == 0) prefix[i][j] = prefix[i][j - 1] + mat[i][j];
        else if (j == 0) prefix[i][j] = prefix[i - 1][j] + mat[i][j];
        else prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + mat[i][j];
      };
    };
    vector<vector<int>> answer(m, vector<int>(n, 0));
    /* top_row = 0
       down_row = 1
       left_col = 1
       right_col = 2
     answer = { 12 21 
    */
    for (int i = 0; i < m; i++)
      for (int j = 0; j < n; j++) {
        int top_row = max(0, i - k), down_row = min(m - 1, i + k);
        int left_col = max(0, j - k), right_col = min(n - 1, j + k);
        if (top_row == 0 && left_col == 0) answer[i][j] = prefix[down_row][right_col];
        else if (top_row == 0) answer[i][j] = prefix[down_row][right_col] - prefix[down_row][left_col - 1];
        else if (left_col == 0) answer[i][j] = prefix[down_row][right_col] - prefix[top_row - 1][right_col];
        else answer[i][j] = prefix[down_row][right_col] - prefix[top_row - 1][right_col] - prefix[down_row][left_col - 1] + prefix[top_row - 1][left_col - 1];
      };
    return answer;
  };
};


/* 二叉树用数组表示，父节点的下标和子节点的下标的关系 
        0
   1         2
 3   4     5     6
7 8 9 10 11 12 13 14

fathers[x] = (x - 1) / 2;
*/
/* 时间复杂度：O(N), 空间复杂度：O(N) */

#include <unordered_map>

using namespace std;

class Solution{
public:
  void dfs1(TreeNode* cur, TreeNode* fa, unordered_map<TreeNode*, TreeNode*>& father) {
    if (cur == NULL) return;
    father[cur] = fa;
    dfs1(cur->left, cur, father);
    dfs1(cur->right, cur, father);
  };
  bool OK(TreeNode* cur, unordered_map<TreeNode*, TreeNode*>& father) {
    if (cur == NULL || father[cur] == NULL || father[father[cur]] == NULL || (father[father[cur]]->val & 1) != 0) return false;
    else return true;
  };
  int dfs2(TreeNode* root, unordered_map<TreeNode*, TreeNode*>& father) {
    if (root == NULL) return 0;
    return (OK(root, father) ? root->val : 0) + dfs2(root->left, father) + dfs2(root->right, father);
  };
  int sumEvenGrandparent(TreeNode* root) {
    /* 遍历一遍将值存储在数组中 */
    unordered_map<TreeNode*, TreeNode*> father;
    dfs1(root, NULL, father);    
    return dfs2(root, father);
  };
};









/* 遍历每个子字符串，然后判断随后截取长度相同的子字符串是否与当前子字符串相等即可，*/
/* 时间复杂度：O(N^2)，空间复杂度：O(1) */
/* 测试用例：text = "aabcaabc" ans = 3 */

#include <string>
#include <set>
#include <functional>
#include <iostream>

using LL = long long;
using namespace std;

class Solution{
public:
  const int mod = 1e9 + 7;
  int getHash(const vector<int>& pre, const vector<int>& mul, int l, int r) {
    return (pre[r + 1] - (LL)pre[l] * mul[r - l + 1] % mod + mod) % mod;
  };
  int distinctEchoSubstrings(string text) {
    int len = text.size(), k = 29;
    vector<int> prefix(len + 1, 0), mul(len + 1, 0); 
    prefix[0] = 0;
    mul[0] = 1;
    for (int i = 1; i <= len; i++)
    {
        prefix[i] = ((LL)prefix[i - 1] * k + text[i - 1]) % mod;
        mul[i] = (LL)mul[i - 1] * k % mod;
    };
    unordered_set<int> seen[len];
    int ans = 0;
    for (int i = 0; i < len; i++) {
      for (int j = i + 1; j < len; j++) {
        int l = j - i;
        if (j + l <= len) {
          int hash_left = getHash(prefix, mul, i, j - 1);
          if (!seen[l - 1].count(hash_left) && hash_left == getHash(prefix, mul, j, j + l - 1)) {
            ++ans;
            seen[l - 1].insert(hash_left);
          };
        };
      };
    }
    return ans;
  };
};



--------------------------2022.2.9-----------------------------

/* 遍历整个数组，将所有偶数和奇数元素分别取出成为单独的数组，然后再进行拼接即可 */
/* 测试用例：nums = {2,1,4,3} */
/* 时间复杂度：O(N)，空间复杂度：O(N) */

#include <vector>

using namespace std;

class Solution {
public:
  vector<int> sortArrayByParity(vector<int>& nums) {
    vector<int> odds, evens, ans;
    /* odds = {1, 3} evens = {2, 4} */
    for (auto& num : nums)
      if (num & 1) odds.push_back(num);
      else evens.push_back(num);
    for (auto &num : evens)
      ans.push_back(num); // ans = {2, 4}
    for (auto &num : odds)
      ans.push_back(num); // ans = {2, 4, 1, 3}
    return ans; 
  };
};

/* 动态规划，遍历整个数组，用两个变量记录当前篮子里水果的位置信息并不断更新，直到遇到一个水果和这两个都不相同，那么就需要把位置信息最小的那个水果替换掉
* 同时维持一个 tot 来记录当前收集的这两种水果的最大数目。
* 特殊考虑成环，需要重复这个数组的遍历
*/

/* 测试用例：fruits = [0, 0, 1, 1] ans = 4 */
/* 时间复杂度：O(N), 空间复杂度：O(1) */

#include <vector>

using namespace std;

class Solution{
public:
  int totalFruit(vector<int>& fruits){
    int end1 = -1, end2 = -1, start1 = -1, start2 = -1, tot1 = 0, tot2 = 0, ans = 0;
    for (int i = 0; i < fruits.size(); i++) {      
      // tot1 = 2
      // tot2 = 0
      // start1 = 0
      // end1 = 1
      // start2 = 2
      // end2 = 2
      // ans = 2
      if (end1 >= 0 && fruits[i] == fruits[end1]) {
        tot1++;
        end1 = i;
      } else if (end2 >= 0 && fruits[i] == fruits[end2]) {
        tot2++;
        end2 = i; 
      } else if (end1 <= end2) {
        tot1 = 1;
        tot2 = i - end1 - 1;
        start1 = end1 = i;
      } else {
        tot2 = 1;
        tot1 = i - end2 - 1;
        start2 = end2 = i;
      };
      ans = max(ans, tot1 + tot2);
    };
    return ans;
  };
};


/* 二分法，将 arr 分成两个子数组，然后分别求解他们的 min(b) 的总和再相加，中间每次处理都需要 NlogN 的时间，*/
/* 时间复杂度：O(NlogNlogN)，空间复杂度 O(NlogN) */
/* 测试用例：arr = {3,1,2,4} ans = 17 */

#include <vector>
#include <algorithm>

using LL = long long;
using namespace std;

class Solution{
public:
  const int mod = (int)1e9 + 7;
  int _sumSubarrayMins(vector<int>& arr, int left, int right, int dir, vector<int>& m) {
    if (left == right) {
      m.push_back(arr[left]);
      return arr[left];
    };

    int mid = (left + right) >> 1;
    vector<int> m1, m2;
    int tot = ((LL)_sumSubarrayMins(arr, left, mid, 1, m1) + (LL)_sumSubarrayMins(arr, mid + 1, right, 0, m2)) % mod;
    int len1 = m1.size(), len2 = m2.size();
    vector<int> prefix1(len1 + 1, 0), prefix2(len2 + 1, 0);
    for (int i = 0; i < len1; i++) prefix1[i + 1] = prefix1[i] + m1[i];
    for (int i = 0; i < len2; i++) prefix2[i + 1] = prefix2[i] + m2[i];
    for (int i = 0; i < len1; i++) {
        int idx = upper_bound(m2.begin(), m2.end(), m1[i]) - m2.begin();
        tot = ((LL)tot + (LL)(len2 - idx) * (LL)m1[i] + (LL)prefix2[idx]) % mod;
    };
    if (dir == 0) /* 原数组右侧 */ {
      m.push_back(arr[left]);
      for (int i = left + 1; i <= right; i++)
        m.push_back(min(m.back(), arr[i]));
    } else {
      m.push_back(arr[right]);
      for (int i = right - 1; i >= left; i--)
        m.push_back(min(m.back(), arr[i]));
    };
    sort(m.begin(), m.end());
    return tot;
  };
  int sumSubarrayMins(vector<int>& arr) {
    vector<int> m;
    return _sumSubarrayMins(arr, 0, arr.size() - 1, 0, m);  
  };
};


/* 构造回文数，计算它的平方，如果在范围内且也是回文数则记录在数组中 */

#include <vector>
#include <string>
#include <cstring>
#include <algorithm>

using namespace std;

class Solution {
public:
  int64_t reverse_int(int64_t x) {
    int64_t ans = 0;
    while (x > 0) {
      ans = 10 * ans + x % 10;
      x /= 10;
    };
    return ans;
  };
  bool judge(int64_t x) {
    return x == reverse_int(x);
  };
  int superpalindromesInRange(string left, string right) {
     int n = 100000, UP = (int)1e9 + 7;
     int64_t l = stoll(left), r = stoll(right), cnt = 0;
     for (int i = 1; i < n; i++) {
       string ori = to_string(i);
       string rev = ori; reverse(rev.begin(), rev.end());
       string str1 = ori + rev;
       int64_t num1 = stoll(str1);
       if (num1 < UP) {
         num1 = num1 * num1;
         if (l <= num1 && num1 <= r) cnt += judge(num1);
         else if (l > r) break;
       } else break;
     };
     for (int i = 1; i < n; i++) {
       string ori = to_string(i);
       string rev = ori; reverse(rev.begin(), rev.end());
       string str2 = ori.substr(0, ori.size() - 1) + rev;
       int64_t num2 = stoll(str2);
       if (num2 < UP) {
         num2 = num2 * num2;
         if (l <= num2 && num2 <= r) cnt += judge(num2);
         else if (l > r) break;
       } else break;
     };
     return cnt;
  };
};



--------------------2022.2.10----------------------------

/* 遍历两边字符串，分别统计1和0连续出现的最长长度，比较即可 */
/* 时间复杂度：O(N)，空间复杂度：O(1) */
/* 测试用例: 100011 */

using namespace std;

class Solution{
public:
  bool checkZeroOnes(string s){
    int len = s.size(), MAX1 = 0, MAX2 = 0; // len = 6, MAX1 = 0, MAX2 = 0
    int tmp1 = s[0] == '1', tmp2 = s[0] == '0'; // tmp1 = 1, tmp2 = 0
    for (int i = 1; i < len; i++) {
      /* 
         i = 1, tmp1 = 0, tmp2 = 1, MAX1 = 1, MAX2 = 1
         i = 2, tmp1 = 0, tmp2 = 2, MAX1 = 1, MAX2 = 2
         i = 3, tmp1 = 0, tmp2 = 3, MAX1 = 1, MAX2 = 3
         i = 4, tmp1 = 1, tmp2 = 0, MAX1 = 1, MAX2 = 3
         i = 5, tmp1 = 2, tmp2 = 0, MAX1 = 2, MAX2 = 3
      */
      MAX1 = max(MAX1, tmp1);
      MAX2 = max(MAX2, tmp2);
      if (s[i] == '1') {
        tmp1++;
        tmp2 = 0;
      } else {
        tmp2++;
        tmp1 = 0;
      };
    };
    MAX1 = max(MAX1, tmp1);
    MAX2 = max(MAX2, tmp2);
    return MAX1 > MAX2; // 2 > 3 = false
  };
};







































































