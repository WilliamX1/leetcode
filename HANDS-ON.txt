x x --> y x
y y       y x 

y y --> y x
x x      y x

x y --> x x --> y x
y x       y y      y x

/* 先分别统计这两对字符串中这两种格式的对儿 <x, y> 和 <y, x> 有多少 */
/* 然后如果 <x, y> 的数量和 <y, x> 的数量之和是奇数，则直接返回 -1 */
/* 否则如果每个都是偶数，则返回和的一半。如果每个都是奇数，则返回和的一半 + 1 */

/* 构造测试样例：
* s1 = "xxx", s2 = "yyy", answer = -1.
* s1 = "xyyx", s2 = "yxxy", answer = 2. 
*/

#include <string>

class Solution {
public:
	int minimumSwap(string s1, string s2) {
		int cnt1 = 0, cnt2 = 0;
		int len = s1.size(); /* len = 4 */
		for (int i = 0; i < len; i++) {
			if (s1[i] == 'x' && s2[i] == 'y') cnt1++;
			else if (s1[i] == 'y' && s2[i] == 'x') cnt2++;
			else {};
		}; /* cnt1 = 2, cnt2 = 2 */
		int ans = (cnt1 + cnt2) & 1 ? -1 : ((cnt1 + cnt2) >> 1) + (cnt1 & 1);
		return ans; /* ans = 2 */
	};
};





/* 先统计出所有的奇数数字的位置，然后以 k 为大小的滑动窗口去遍历
* 这样就能算出恰好含有 k 个奇数数字的 “极小” 子数组，然后再去看两侧奇数的位置，相乘就可以算出含有部分 “多余偶数” 的数组有多少个
*/

/* 测试用例, nums = <1 1 2 1 1>, k = 2, ans = 5 */
/* 时间复杂度: O(N), 空间复杂度: O(N) */

#include <vector>

using namespace std;

class Solution{
public:
	int numberOfSubarrays(vector<int>& nums, int k ){
	  /* nums: 1 1 2 1 1 */
		int len = nums.size();
		vector<int> v; v.push_back(-1);
		for (int i = 0; i < len; i++)
			if (nums[i] & 1) {
				v.push_back(i);
			};
		v.push_back(len);
		/* v: -1 0 1 3 4 5 */
		int ans = 0;
		for (int start = 1; start < v.size(); start++) {
			int end = start + k - 1;
			if (end >= v.size() - 1) break;
			else ans += (v[start] - v[start - 1]) * (v[end + 1] - v[end]); /* ans += 2 += 1 += 2 = 5 */
		};
		return ans;
	};
};








/* 我们使用栈把字符串中的括号依次压栈，每次压栈的规则是
* 如果栈为空，则直接压栈。如果栈顶元素是左括号，且当前元素是右括号，刚好匹配，则探出栈顶元素且不压栈当前元素。否则，将当前元素压栈。最后的栈内所有元素就是要被移除的括号。
* 每次压栈时需要记录位置信息，以便后续删除对应字符串中的括号来获得新的合法字符串。
* 因此，可以压栈一个数字，如果是左括号则用负号，右括号则用正号，下标从 1 开始。
*/

/* 测试用例: s = "(d)(f))", ans = 1 */
/* 时间复杂度: O(N), 空间复杂度: O(N) */

#include<stack>

class Solution{
public:
	string minRemoveToMakeValid(string s){
		stack<int> ele;
		for (int i = 0; i < s.size(); i++) 
			if (s[i] == '(') ele.push(-(i + 1));
			else if (s[i] == ')') {
				if (ele.empty()) ele.push(i + 1);
				else if (ele.top() < 0) ele.pop();
				else ele.push(i + 1);
			} else {};
		string ans = "";
		int cur_idx = s.size();
		
		while (!ele.empty()) {
			int last_idx = abs(ele.top()) - 1;
			ele.pop();
			ans = s.substr(last_idx + 1, cur_idx - last_idx - 1) + ans;
			cur_idx = last_idx;
		};
		ans = s.substr(0, cur_idx - 0) + ans;
		/*for (int i = s.size() - 1; i >= 0; i--) {
			if (!ele.empty() && abs(ele.top()) - 1 == i) {
				ele.pop();
			} else {
				ans = s[i] + ans;
			};
		};*/
		return ans;
	};
};



/* 查看了维基百科 <裴蜀定理> */
/* 当且仅当 m 是 a, b 的最大公约数的倍数，ax + by = m 才有解, 此题中 m = 1，因此就是判断 a 和 b 互质 */

class Solution{
public:
	int gcd(int a, int b) {
		return a == 0 ? b : gcd(b % a, a);
	};
	bool isGoodArray(vector<int>& nums) {
		int a = nums[0];
		for (auto num: nums)
			a = gcd(a, num);
		return a == 1;
	};
};