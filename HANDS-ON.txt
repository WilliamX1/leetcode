----------------------2022.2.7------------------------

x x --> y x
y y       y x 

y y --> y x
x x      y x

x y --> x x --> y x
y x       y y      y x

/* 先分别统计这两对字符串中这两种格式的对儿 <x, y> 和 <y, x> 有多少 */
/* 然后如果 <x, y> 的数量和 <y, x> 的数量之和是奇数，则直接返回 -1 */
/* 否则如果每个都是偶数，则返回和的一半。如果每个都是奇数，则返回和的一半 + 1 */

/* 构造测试样例：
* s1 = "xxx", s2 = "yyy", answer = -1.
* s1 = "xyyx", s2 = "yxxy", answer = 2. 
*/

#include <string>

class Solution {
public:
	int minimumSwap(string s1, string s2) {
		int cnt1 = 0, cnt2 = 0;
		int len = s1.size(); /* len = 4 */
		for (int i = 0; i < len; i++) {
			if (s1[i] == 'x' && s2[i] == 'y') cnt1++;
			else if (s1[i] == 'y' && s2[i] == 'x') cnt2++;
			else {};
		}; /* cnt1 = 2, cnt2 = 2 */
		int ans = (cnt1 + cnt2) & 1 ? -1 : ((cnt1 + cnt2) >> 1) + (cnt1 & 1);
		return ans; /* ans = 2 */
	};
};





/* 先统计出所有的奇数数字的位置，然后以 k 为大小的滑动窗口去遍历
* 这样就能算出恰好含有 k 个奇数数字的 “极小” 子数组，然后再去看两侧奇数的位置，相乘就可以算出含有部分 “多余偶数” 的数组有多少个
*/

/* 测试用例, nums = <1 1 2 1 1>, k = 2, ans = 5 */
/* 时间复杂度: O(N), 空间复杂度: O(N) */

#include <vector>

using namespace std;

class Solution{
public:
	int numberOfSubarrays(vector<int>& nums, int k ){
	  /* nums: 1 1 2 1 1 */
		int len = nums.size();
		vector<int> v; v.push_back(-1);
		for (int i = 0; i < len; i++)
			if (nums[i] & 1) {
				v.push_back(i);
			};
		v.push_back(len);
		/* v: -1 0 1 3 4 5 */
		int ans = 0;
		for (int start = 1; start < v.size(); start++) {
			int end = start + k - 1;
			if (end >= v.size() - 1) break;
			else ans += (v[start] - v[start - 1]) * (v[end + 1] - v[end]); /* ans += 2 += 1 += 2 = 5 */
		};
		return ans;
	};
};








/* 我们使用栈把字符串中的括号依次压栈，每次压栈的规则是
* 如果栈为空，则直接压栈。如果栈顶元素是左括号，且当前元素是右括号，刚好匹配，则探出栈顶元素且不压栈当前元素。否则，将当前元素压栈。最后的栈内所有元素就是要被移除的括号。
* 每次压栈时需要记录位置信息，以便后续删除对应字符串中的括号来获得新的合法字符串。
* 因此，可以压栈一个数字，如果是左括号则用负号，右括号则用正号，下标从 1 开始。
*/

/* 测试用例: s = "(d)(f))", ans = 1 */
/* 时间复杂度: O(N), 空间复杂度: O(N) */

#include<stack>

class Solution{
public:
	string minRemoveToMakeValid(string s){
		stack<int> ele;
		for (int i = 0; i < s.size(); i++) 
			if (s[i] == '(') ele.push(-(i + 1));
			else if (s[i] == ')') {
				if (ele.empty()) ele.push(i + 1);
				else if (ele.top() < 0) ele.pop();
				else ele.push(i + 1);
			} else {};
		string ans = "";
		int cur_idx = s.size();
		
		while (!ele.empty()) {
			int last_idx = abs(ele.top()) - 1;
			ele.pop();
			ans = s.substr(last_idx + 1, cur_idx - last_idx - 1) + ans;
			cur_idx = last_idx;
		};
		ans = s.substr(0, cur_idx - 0) + ans;
		/*for (int i = s.size() - 1; i >= 0; i--) {
			if (!ele.empty() && abs(ele.top()) - 1 == i) {
				ele.pop();
			} else {
				ans = s[i] + ans;
			};
		};*/
		return ans;
	};
};



/* 查看了维基百科 <裴蜀定理> */
/* 当且仅当 m 是 a, b 的最大公约数的倍数，ax + by = m 才有解, 此题中 m = 1，因此就是判断 a 和 b 互质 */

class Solution{
public:
	int gcd(int a, int b) {
		return a == 0 ? b : gcd(b % a, a);
	};
	bool isGoodArray(vector<int>& nums) {
		int a = nums[0];
		for (auto num: nums)
			a = gcd(a, num);
		return a == 1;
	};
};


-----------------------2022.2.8-----------------------------


/* 遍历原来数组，每次将奇数位上的数量的偶数位上的值压入结果数组，返回即可 */
/* 测试用例：v = {1 3 2 4 5 2}, ans = {3 4 4 2 2 2 2 2} */
/* 时间复杂度：O(N * max(nums)) 空间复杂度：O(N * max(nums)) */

#include <vector>

using namespace std;

class Solution{
public:
  vector<int> decompressRLElist(vector<int>& nums){
    vector<int> ans;
    int len = nums.size();
    for (int i = 0; i < len; i += 2) {
      for (int j = 0; j < nums[i]; j++) {
          ans.push_back(nums[i + 1]);
      };
    };
    return ans;
  };
};


/* 前缀和思想：按行求出前缀和，计算每个元素的时候都根据前缀和按行求出的总和即可 */
/* 测试用例：mat = { 1 2 3      k = 1, ans = { 12, 21, 16
                   4 5 6                     27, 45, 33 
                   7 8 9 }                   24, 39, 28}
*/
/* 时间复杂度：O(m * n) 空间复杂度：O(m * n) */

#include <vector>

using namespace std;

class Solution{
public:
  vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {
    int m = mat.size(), n = mat[0].size(); /* m = 3, n = 3 */
    vector<vector<int>> prefix(m, vector<int>(n, 0));
    /* prefix = { 1 3 6 
                  5 12 21
                  12 27 45 }
    */
    for (int i = 0; i < m; i++) {
      for (int j = 0; j < n; j++) {
        if (i == 0 && j == 0) prefix[i][j] = mat[i][j]; 
        else if (i == 0) prefix[i][j] = prefix[i][j - 1] + mat[i][j];
        else if (j == 0) prefix[i][j] = prefix[i - 1][j] + mat[i][j];
        else prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + mat[i][j];
      };
    };
    vector<vector<int>> answer(m, vector<int>(n, 0));
    /* top_row = 0
       down_row = 1
       left_col = 1
       right_col = 2
     answer = { 12 21 
    */
    for (int i = 0; i < m; i++)
      for (int j = 0; j < n; j++) {
        int top_row = max(0, i - k), down_row = min(m - 1, i + k);
        int left_col = max(0, j - k), right_col = min(n - 1, j + k);
        if (top_row == 0 && left_col == 0) answer[i][j] = prefix[down_row][right_col];
        else if (top_row == 0) answer[i][j] = prefix[down_row][right_col] - prefix[down_row][left_col - 1];
        else if (left_col == 0) answer[i][j] = prefix[down_row][right_col] - prefix[top_row - 1][right_col];
        else answer[i][j] = prefix[down_row][right_col] - prefix[top_row - 1][right_col] - prefix[down_row][left_col - 1] + prefix[top_row - 1][left_col - 1];
      };
    return answer;
  };
};


/* 二叉树用数组表示，父节点的下标和子节点的下标的关系 
        0
   1         2
 3   4     5     6
7 8 9 10 11 12 13 14

fathers[x] = (x - 1) / 2;
*/
/* 时间复杂度：O(N), 空间复杂度：O(N) */

#include <unordered_map>

using namespace std;

class Solution{
public:
  void dfs1(TreeNode* cur, TreeNode* fa, unordered_map<TreeNode*, TreeNode*>& father) {
    if (cur == NULL) return;
    father[cur] = fa;
    dfs1(cur->left, cur, father);
    dfs1(cur->right, cur, father);
  };
  bool OK(TreeNode* cur, unordered_map<TreeNode*, TreeNode*>& father) {
    if (cur == NULL || father[cur] == NULL || father[father[cur]] == NULL || (father[father[cur]]->val & 1) != 0) return false;
    else return true;
  };
  int dfs2(TreeNode* root, unordered_map<TreeNode*, TreeNode*>& father) {
    if (root == NULL) return 0;
    return (OK(root, father) ? root->val : 0) + dfs2(root->left, father) + dfs2(root->right, father);
  };
  int sumEvenGrandparent(TreeNode* root) {
    /* 遍历一遍将值存储在数组中 */
    unordered_map<TreeNode*, TreeNode*> father;
    dfs1(root, NULL, father);    
    return dfs2(root, father);
  };
};









/* 遍历每个子字符串，然后判断随后截取长度相同的子字符串是否与当前子字符串相等即可，*/
/* 时间复杂度：O(N^2)，空间复杂度：O(1) */
/* 测试用例：text = "aabcaabc" ans = 3 */

#include <string>
#include <set>
#include <functional>
#include <iostream>

using LL = long long;
using namespace std;

class Solution{
public:
  const int mod = 1e9 + 7;
  int getHash(const vector<int>& pre, const vector<int>& mul, int l, int r) {
    return (pre[r + 1] - (LL)pre[l] * mul[r - l + 1] % mod + mod) % mod;
  };
  int distinctEchoSubstrings(string text) {
    int len = text.size(), k = 29;
    vector<int> prefix(len + 1, 0), mul(len + 1, 0); 
    prefix[0] = 0;
    mul[0] = 1;
    for (int i = 1; i <= len; i++)
    {
        prefix[i] = ((LL)prefix[i - 1] * k + text[i - 1]) % mod;
        mul[i] = (LL)mul[i - 1] * k % mod;
    };
    unordered_set<int> seen[len];
    int ans = 0;
    for (int i = 0; i < len; i++) {
      for (int j = i + 1; j < len; j++) {
        int l = j - i;
        if (j + l <= len) {
          int hash_left = getHash(prefix, mul, i, j - 1);
          if (!seen[l - 1].count(hash_left) && hash_left == getHash(prefix, mul, j, j + l - 1)) {
            ++ans;
            seen[l - 1].insert(hash_left);
          };
        };
      };
    }
    return ans;
  };
};







































































